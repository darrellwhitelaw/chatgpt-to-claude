---
phase: 01-zip-parsing-foundation
plan: "03"
type: tdd
wave: 3
depends_on:
  - 01-02
files_modified:
  - src-tauri/src/pipeline/traversal.rs
  - src-tauri/src/pipeline/mod.rs
  - src-tauri/src/pipeline/normalizer.rs
  - src-tauri/tests/traversal_test.rs
autonomous: true
requirements:
  - IMP-05
  - IMP-06

must_haves:
  truths:
    - "The tree traversal produces messages in chronological order (root → leaf), not insertion order"
    - "Given a branched conversation (user retried a response), only the branch pointed to by current_node is returned — not both branches"
    - "Null parent on the root node terminates the walk gracefully without panic"
    - "Missing node IDs in the mapping (defensive: IMP-05) cause early termination, not panic"
    - "Unit tests pass with a hand-crafted HashMap fixture — no real export file needed in the repo"
    - "The normalizer uses linearize_messages for full_text and message_count after traversal is wired in"
  artifacts:
    - path: "src-tauri/src/pipeline/traversal.rs"
      provides: "linearize_messages — walks current_node→parent chain and returns messages in chronological order"
      exports: ["linearize_messages", "should_include_message"]
    - path: "src-tauri/tests/traversal_test.rs"
      provides: "Unit tests: linear chain, branched conversation, missing node, empty mapping"
      contains: "fn test_linear_chain"
    - path: "src-tauri/src/pipeline/normalizer.rs"
      provides: "Updated normalize() calls linearize_messages for accurate full_text and message_count"
      contains: "linearize_messages"
  key_links:
    - from: "src-tauri/tests/traversal_test.rs"
      to: "src-tauri/src/pipeline/traversal.rs"
      via: "linearize_messages called with HashMap fixture"
      pattern: "linearize_messages"
    - from: "src-tauri/src/pipeline/normalizer.rs"
      to: "src-tauri/src/pipeline/traversal.rs"
      via: "linearize_messages(mapping, current_node) replaces mapping.values() iteration"
      pattern: "linearize_messages"
---

<objective>
Implement and TDD the node-graph tree traversal for reconstructing conversation message order. The conversations.json `mapping` field is a keyed tree, not a flat list — the only correct traversal is walking from `current_node` backward through `parent` references. This is the highest-risk correctness requirement in Phase 1 (silently wrong output if done incorrectly).

Purpose: TDD forces a clear I/O contract before writing the implementation, and the branched fixture verifies the exact edge case that causes silent errors (iterating mapping.values() instead of following parent chain).
Output: `traversal.rs` with `linearize_messages` function; Rust unit tests passing against a deterministic fixture; normalizer updated to use traversal.
</objective>

<execution_context>
@/Users/darrellwhitelaw/.claude/get-shit-done/workflows/execute-plan.md
@/Users/darrellwhitelaw/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-zip-parsing-foundation/01-RESEARCH.md
@.planning/phases/01-zip-parsing-foundation/01-02-SUMMARY.md
</context>

<feature>
  <name>linearize_messages — node-graph tree traversal</name>
  <files>
    src-tauri/src/pipeline/traversal.rs
    src-tauri/tests/traversal_test.rs
  </files>
  <behavior>
    Signature: `pub fn linearize_messages(mapping: &HashMap<String, MessageNode>, current_node: &str) -> Vec<Message>`

    Cases (all verifiable with inline HashMap fixtures):

    1. Linear chain (root → A → B → C, current_node = "C"):
       Input: mapping = {root: {parent: None, msg: None}, A: {parent: "root", msg: User("Hello")}, B: {parent: "A", msg: Assistant("Hi")}, C: {parent: "B", msg: User("Thanks")}}
       Output: [User("Hello"), Assistant("Hi"), User("Thanks")] — chronological order

    2. Branched conversation (user retried response):
       Input: mapping = {root: {parent: None}, A: {parent: "root", msg: User("Hello")}, B1: {parent: "A", msg: Assistant("Response v1")}, B2: {parent: "A", msg: Assistant("Response v2")}, C: {parent: "B2", msg: User("Thanks")}}, current_node = "C"
       Output: [User("Hello"), Assistant("Response v2"), User("Thanks")] — B1 excluded
       NOT: both B1 and B2 in output (the mapping.values() bug produces this)

    3. Missing parent node (defensive):
       Input: mapping where current_node's ancestor chain contains an ID not in mapping
       Output: partial chain up to the missing node — no panic

    4. Empty mapping:
       Input: mapping = {}, current_node = "any"
       Output: [] — empty vec, no panic

    5. Filter: system/tool/memory messages excluded
       Only messages where author.role is "user" or "assistant" AND content is Some AND content is non-empty are included
  </behavior>
  <implementation>
    Walk current_node → parent backward, collecting messages into a Vec, then reverse.
    Use HashMap::get() (not indexing) to avoid panics on missing keys.
    Call should_include_message() to filter system/tool/memory messages.
    The reverse at the end converts "leaf-to-root" collection order into "root-to-leaf" chronological order.
  </implementation>
</feature>

<tasks>

<task type="auto">
  <name>RED: Write failing tests for linearize_messages</name>
  <files>
    src-tauri/tests/traversal_test.rs
    src-tauri/src/pipeline/traversal.rs
    src-tauri/src/pipeline/mod.rs
  </files>
  <action>
Create the test file FIRST. The traversal module must exist (even empty) so the test can reference it — but the function must NOT be implemented yet (RED = tests fail).

**`src-tauri/src/pipeline/traversal.rs`** — empty stub to make tests compile:
```rust
use crate::pipeline::json_parser::{Message, MessageNode};
use std::collections::HashMap;

pub fn linearize_messages(
    _mapping: &HashMap<String, MessageNode>,
    _current_node: &str,
) -> Vec<Message> {
    vec![] // Stub — tests will fail (RED)
}

pub fn should_include_message(msg: &Message) -> bool {
    false // Stub
}
```

Update **`src-tauri/src/pipeline/mod.rs`** to expose traversal:
```rust
pub mod json_parser;
pub mod normalizer;
pub mod traversal;
pub mod zip_reader;
```

**`src-tauri/tests/traversal_test.rs`** — complete test suite:
```rust
use chatgpt_to_claude_lib::pipeline::json_parser::{Author, Content, Message, MessageNode};
use chatgpt_to_claude_lib::pipeline::traversal::linearize_messages;
use std::collections::HashMap;

/// Helper: build a minimal MessageNode with user message
fn user_node(id: &str, parent: Option<&str>, text: &str) -> MessageNode {
    MessageNode {
        id: id.to_string(),
        parent: parent.map(|s| s.to_string()),
        children: vec![],
        message: Some(Message {
            id: id.to_string(),
            author: Author { role: "user".to_string(), name: None },
            create_time: None,
            content: Some(Content {
                content_type: "text".to_string(),
                parts: vec![serde_json::Value::String(text.to_string())],
            }),
            metadata: serde_json::Value::Null,
        }),
    }
}

/// Helper: build an assistant MessageNode
fn assistant_node(id: &str, parent: Option<&str>, text: &str) -> MessageNode {
    MessageNode {
        id: id.to_string(),
        parent: parent.map(|s| s.to_string()),
        children: vec![],
        message: Some(Message {
            id: id.to_string(),
            author: Author { role: "assistant".to_string(), name: None },
            create_time: None,
            content: Some(Content {
                content_type: "text".to_string(),
                parts: vec![serde_json::Value::String(text.to_string())],
            }),
            metadata: serde_json::Value::Null,
        }),
    }
}

/// Helper: build a structural node (no message — root or branch point)
fn struct_node(id: &str, parent: Option<&str>) -> MessageNode {
    MessageNode {
        id: id.to_string(),
        parent: parent.map(|s| s.to_string()),
        children: vec![],
        message: None,
    }
}

#[test]
fn test_linear_chain() {
    let mut mapping = HashMap::new();
    mapping.insert("root".to_string(), struct_node("root", None));
    mapping.insert("a".to_string(), user_node("a", Some("root"), "Hello"));
    mapping.insert("b".to_string(), assistant_node("b", Some("a"), "Hi there"));
    mapping.insert("c".to_string(), user_node("c", Some("b"), "Thanks"));

    let messages = linearize_messages(&mapping, "c");
    assert_eq!(messages.len(), 3, "Expected 3 messages in linear chain");
    // Verify chronological order (root → leaf)
    assert_eq!(
        messages[0].author.role, "user",
        "First message should be user"
    );
    assert_eq!(
        messages[2].author.role, "user",
        "Last message should be user"
    );
}

#[test]
fn test_branched_conversation_follows_current_node() {
    // B1 and B2 are both children of A; current_node points to C (via B2)
    // B1 must NOT appear in output
    let mut mapping = HashMap::new();
    mapping.insert("root".to_string(), struct_node("root", None));
    mapping.insert("a".to_string(), user_node("a", Some("root"), "Hello"));
    mapping.insert("b1".to_string(), assistant_node("b1", Some("a"), "Response v1"));
    mapping.insert("b2".to_string(), assistant_node("b2", Some("a"), "Response v2"));
    mapping.insert("c".to_string(), user_node("c", Some("b2"), "Thanks"));

    let messages = linearize_messages(&mapping, "c");

    // Must include b2, must NOT include b1
    let has_v1 = messages
        .iter()
        .any(|m| {
            m.content
                .as_ref()
                .and_then(|c| c.parts.first())
                .and_then(|p| p.as_str())
                == Some("Response v1")
        });
    let has_v2 = messages
        .iter()
        .any(|m| {
            m.content
                .as_ref()
                .and_then(|c| c.parts.first())
                .and_then(|p| p.as_str())
                == Some("Response v2")
        });

    assert!(!has_v1, "Branched-off response v1 must NOT appear in output");
    assert!(has_v2, "Active branch response v2 MUST appear in output");
    assert_eq!(messages.len(), 3, "Should have user + v2 assistant + user");
}

#[test]
fn test_missing_parent_node_does_not_panic() {
    // current_node's parent chain leads to a node ID not in mapping
    let mut mapping = HashMap::new();
    mapping.insert("c".to_string(), user_node("c", Some("missing_parent"), "Hello"));

    // Must not panic — returns partial chain
    let messages = linearize_messages(&mapping, "c");
    assert!(messages.len() <= 1, "Should return at most the node itself");
}

#[test]
fn test_empty_mapping_returns_empty() {
    let mapping: HashMap<String, MessageNode> = HashMap::new();
    let messages = linearize_messages(&mapping, "any_node");
    assert!(messages.is_empty(), "Empty mapping should return empty vec");
}

#[test]
fn test_system_messages_excluded() {
    let mut mapping = HashMap::new();
    mapping.insert("root".to_string(), struct_node("root", None));
    // System message — should be filtered
    mapping.insert(
        "sys".to_string(),
        MessageNode {
            id: "sys".to_string(),
            parent: Some("root".to_string()),
            children: vec![],
            message: Some(Message {
                id: "sys".to_string(),
                author: Author { role: "system".to_string(), name: None },
                create_time: None,
                content: Some(Content {
                    content_type: "text".to_string(),
                    parts: vec![serde_json::Value::String("System init".to_string())],
                }),
                metadata: serde_json::Value::Null,
            }),
        },
    );
    mapping.insert("a".to_string(), user_node("a", Some("sys"), "Hello"));

    let messages = linearize_messages(&mapping, "a");
    assert_eq!(messages.len(), 1, "System message must be excluded");
    assert_eq!(messages[0].author.role, "user");
}
```

Run tests — they MUST fail (RED phase):
```bash
cd /Users/darrellwhitelaw/Claude/chatgpt-to-claude
cargo test --manifest-path src-tauri/Cargo.toml 2>&1 | tail -20
```

Commit this RED state: `git commit -m "test(01-03): add failing tests for linearize_messages tree traversal"`
  </action>
  <verify>
    <automated>cd /Users/darrellwhitelaw/Claude/chatgpt-to-claude && cargo test --manifest-path src-tauri/Cargo.toml 2>&1 | grep -E "(FAILED|test result)" | head -5</automated>
    <manual>Tests must compile but FAIL — "test result: FAILED" confirms RED phase is correct</manual>
  </verify>
  <done>Tests compile (no cargo errors) but fail at runtime — RED phase confirmed. All 5 test functions exist and assert on linearize_messages behavior.</done>
</task>

<task type="auto">
  <name>GREEN + REFACTOR: Implement linearize_messages and wire into normalizer</name>
  <files>
    src-tauri/src/pipeline/traversal.rs
    src-tauri/src/pipeline/normalizer.rs
  </files>
  <action>
**`src-tauri/src/pipeline/traversal.rs`** — full implementation:

```rust
use crate::pipeline::json_parser::{Message, MessageNode};
use std::collections::HashMap;

/// Reconstructs the conversation's message order by walking the node-graph
/// from `current_node` backward through parent references, then reversing.
///
/// This is the ONLY correct way to traverse conversations.json:
/// - mapping.values() iteration produces random order (not conversation order)
/// - mapping.values() includes all branches (not just the branch the user saw)
///
/// The walk: current_node → parent → parent → ... → root (null parent)
/// Collected in reverse chronological order, then reversed to chronological.
pub fn linearize_messages(
    mapping: &HashMap<String, MessageNode>,
    current_node: &str,
) -> Vec<Message> {
    let mut messages: Vec<Message> = Vec::new();
    let mut node_id = Some(current_node.to_string());

    loop {
        let id = match node_id.take() {
            Some(id) => id,
            None => break,
        };

        let node = match mapping.get(&id) {
            Some(n) => n,
            None => break, // Missing node — terminate gracefully (IMP-05)
        };

        if let Some(ref msg) = node.message {
            if should_include_message(msg) {
                messages.push(msg.clone());
            }
        }

        node_id = node.parent.clone();
    }

    // Built root→leaf backward (leaf first); reverse to get chronological order
    messages.reverse();
    messages
}

/// Returns true if a message should be included in the linearized output.
/// Only user and assistant messages with non-empty content are included.
/// System, tool, memory, and tether_browsing messages are excluded.
pub fn should_include_message(msg: &Message) -> bool {
    let role = msg.author.role.as_str();
    if role != "user" && role != "assistant" {
        return false;
    }
    let Some(ref content) = msg.content else {
        return false;
    };
    // Exclude empty parts arrays
    if content.parts.is_empty() {
        return false;
    }
    // Exclude messages where all parts are null or empty string
    content.parts.iter().any(|p| {
        p.as_str().map(|s| !s.is_empty()).unwrap_or(
            // Non-string parts (image objects, etc.) count as non-empty
            !p.is_null(),
        )
    })
}
```

Run tests — they MUST pass (GREEN phase):
```bash
cd /Users/darrellwhitelaw/Claude/chatgpt-to-claude
cargo test --manifest-path src-tauri/Cargo.toml 2>&1 | tail -10
```

Commit GREEN: `git commit -m "feat(01-03): implement linearize_messages tree traversal"`

**Wire traversal into normalizer** — update `src-tauri/src/pipeline/normalizer.rs`:

Replace the `mapping.values()` loop with `linearize_messages`:

```rust
use crate::pipeline::json_parser::{Content, ConversationExport};
use crate::pipeline::traversal::linearize_messages;

pub struct ConversationRecord {
    pub id: String,
    pub title: String,
    pub created_at: Option<i64>,
    pub message_count: u32,
    pub has_images: bool,
    pub has_code: bool,
    pub token_estimate: u32,
    pub full_text: String,
}

pub fn normalize(export: ConversationExport) -> ConversationRecord {
    let title = export
        .title
        .filter(|t| !t.is_empty())
        .unwrap_or_else(|| "Untitled".to_string());

    let created_at = export.create_time.map(|t| t as i64);

    let messages = if let Some(ref current_node) = export.current_node {
        linearize_messages(&export.mapping, current_node)
    } else {
        vec![] // No current_node — skip traversal, store empty
    };

    let message_count = messages.len() as u32;
    let mut has_images = false;
    let mut has_code = false;
    let mut full_text = String::new();

    for msg in &messages {
        if let Some(ref content) = msg.content {
            let extracted = extract_text(content);
            if !extracted.is_empty() {
                full_text.push_str(&extracted);
                full_text.push('\n');
            }
            if content.content_type == "multimodal_text" {
                has_images = true;
            }
            if content.content_type == "code" {
                has_code = true;
            }
        }
    }

    let token_estimate = (full_text.len() / 4) as u32;

    ConversationRecord {
        id: export.id,
        title,
        created_at,
        message_count,
        has_images,
        has_code,
        token_estimate,
        full_text,
    }
}

fn extract_text(content: &Content) -> String {
    content
        .parts
        .iter()
        .filter_map(|part| part.as_str().map(|s| s.to_string()))
        .collect::<Vec<_>>()
        .join(" ")
}
```

Run all tests again to confirm nothing regressed:
```bash
cd /Users/darrellwhitelaw/Claude/chatgpt-to-claude
cargo test --manifest-path src-tauri/Cargo.toml
```

Commit REFACTOR (wiring): `git commit -m "refactor(01-03): wire linearize_messages into normalizer"`
  </action>
  <verify>
    <automated>cd /Users/darrellwhitelaw/Claude/chatgpt-to-claude && cargo test --manifest-path src-tauri/Cargo.toml 2>&1 | grep -E "test result"</automated>
    <manual>Output must show "test result: ok" with all 5 tests passing and 0 failures</manual>
  </verify>
  <done>
    - All 5 traversal tests pass: linear chain, branched conversation, missing node, empty mapping, system message exclusion
    - `linearize_messages` walks current_node → parent chain backward, reverses to chronological
    - Branched test confirms only current_node's branch is returned
    - `normalizer.rs` uses `linearize_messages` instead of `mapping.values()` iteration
    - `cargo check` and `cargo test` both pass with zero errors
  </done>
</task>

</tasks>

<verification>
```bash
cd /Users/darrellwhitelaw/Claude/chatgpt-to-claude
cargo test --manifest-path src-tauri/Cargo.toml
```
Must show: `test result: ok. 5 passed; 0 failed`

```bash
cargo check --manifest-path src-tauri/Cargo.toml
```
Must exit 0.
</verification>

<success_criteria>
- RED phase: Tests exist and compile but fail against the stub implementation
- GREEN phase: All 5 tests pass with the real linearize_messages implementation
- REFACTOR: normalizer updated to use traversal — mapping.values() iteration removed
- Branched conversation test explicitly verifies only the current_node branch is returned
- Missing node test verifies graceful termination without panic
- 3 atomic commits produced: test commit, feat commit, refactor commit
</success_criteria>

<output>
After completion, create `.planning/phases/01-zip-parsing-foundation/01-03-SUMMARY.md` following the summary template.
</output>
