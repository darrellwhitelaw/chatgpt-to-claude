---
phase: 01-zip-parsing-foundation
plan: "01"
type: execute
wave: 1
depends_on: []
files_modified:
  - src-tauri/Cargo.toml
  - src-tauri/src/lib.rs
  - src-tauri/src/commands/mod.rs
  - src-tauri/src/commands/ingest.rs
  - src-tauri/src/pipeline/mod.rs
  - src-tauri/src/store/mod.rs
  - src-tauri/src/store/db.rs
  - src-tauri/src/store/schema.sql
  - src-tauri/tauri.conf.json
  - src/App.tsx
  - src/main.tsx
  - src/lib/bindings.ts
  - package.json
  - vitest.config.ts
autonomous: true
requirements:
  - IMP-03
  - IMP-04

must_haves:
  truths:
    - "Running `cargo check` in src-tauri/ succeeds with no errors"
    - "Running `pnpm dev` starts the Tauri app window (600x500, centered, not resizable)"
    - "The frontend compiles with TypeScript — no type errors"
    - "The Tauri IPC command `parse_zip` is registered and reachable from the frontend"
    - "AppState with Mutex<Connection> is managed by Tauri and accessible to commands"
    - "SQLite schema is initialized on app startup with the conversations table"
  artifacts:
    - path: "src-tauri/Cargo.toml"
      provides: "Rust dependency manifest — zip, serde, serde_json, rusqlite, tauri"
      contains: "rusqlite"
    - path: "src-tauri/src/lib.rs"
      provides: "Tauri app entry, AppState management, command registration, DB init"
      contains: "AppState"
    - path: "src-tauri/src/commands/ingest.rs"
      provides: "parse_zip command stub with Channel<IngestEvent> signature"
      exports: ["parse_zip"]
    - path: "src-tauri/src/store/db.rs"
      provides: "SQLite init and schema creation"
      contains: "init_schema"
    - path: "src-tauri/tauri.conf.json"
      provides: "Window configuration — 600x500, not resizable, centered"
      contains: "resizable"
    - path: "src/lib/bindings.ts"
      provides: "TypeScript types for IngestEvent and IPC bridge"
      contains: "IngestEvent"
  key_links:
    - from: "src-tauri/src/lib.rs"
      to: "src-tauri/src/commands/ingest.rs"
      via: "tauri::generate_handler![commands::ingest::parse_zip]"
      pattern: "generate_handler"
    - from: "src-tauri/src/lib.rs"
      to: "src-tauri/src/store/db.rs"
      via: "init_schema called in setup() closure"
      pattern: "init_schema"
    - from: "src/lib/bindings.ts"
      to: "src-tauri/src/commands/ingest.rs"
      via: "IngestEvent enum matches TypeScript union type"
      pattern: "IngestEvent"
---

<objective>
Scaffold the Tauri 2 project: Rust workspace, React 19 TypeScript frontend, window configuration, SQLite schema initialization, and a stubbed `parse_zip` Tauri command with the full `Channel<IngestEvent>` IPC signature ready for the pipeline implementation in plan 01-02.

Purpose: Everything in Phase 1 runs inside this scaffold. No pipeline code can be written until the project compiles and the IPC bridge exists.
Output: A working Tauri app that opens a 600x500 centered window. The scaffold runs `pnpm dev`, `cargo check`, and TypeScript compiles cleanly.
</objective>

<execution_context>
@/Users/darrellwhitelaw/.claude/get-shit-done/workflows/execute-plan.md
@/Users/darrellwhitelaw/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-zip-parsing-foundation/01-CONTEXT.md
@.planning/phases/01-zip-parsing-foundation/01-RESEARCH.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Scaffold Tauri project with React TypeScript template</name>
  <files>
    package.json
    pnpm-lock.yaml
    src-tauri/Cargo.toml
    src-tauri/src/lib.rs
    src-tauri/src/main.rs
    src-tauri/tauri.conf.json
    src/main.tsx
    src/App.tsx
    vite.config.ts
    tsconfig.json
    index.html
    vitest.config.ts
  </files>
  <action>
Run `pnpm create tauri-app chatgpt-to-claude` in the working directory root (NOT in a subdirectory — the repo root IS the project). If the scaffolding would create a nested folder, scaffold into the current directory directly using the appropriate flag. Choose: React, TypeScript, pnpm as package manager.

After scaffolding, install additional frontend dependencies:
```
pnpm add zustand lucide-react @tauri-apps/plugin-dialog
pnpm add -D vitest @vitest/ui @testing-library/react @testing-library/user-event jsdom
```

Add shadcn/ui with Tailwind CSS v4:
```
pnpm dlx shadcn@latest init
```
When prompted, use defaults (New York style, neutral color — light theme; do NOT select dark mode).

Add Rust dependencies to `src-tauri/Cargo.toml`:
```toml
[dependencies]
zip = "2"
serde = { version = "1", features = ["derive"] }
serde_json = "1"
rusqlite = { version = "0.32", features = ["bundled"] }
tauri = { version = "2", features = [] }
tauri-plugin-dialog = "2"
```

Configure `vitest.config.ts` with jsdom environment:
```typescript
import { defineConfig } from 'vitest/config';
export default defineConfig({
  test: {
    environment: 'jsdom',
    globals: true,
  },
});
```

Set up `src-tauri/tauri.conf.json` window configuration (per locked decisions):
```json
{
  "app": {
    "windows": [
      {
        "label": "main",
        "title": "ChatGPT to Claude",
        "width": 600,
        "height": 528,
        "resizable": false,
        "center": true,
        "minWidth": 600,
        "maxWidth": 600,
        "minHeight": 528,
        "maxHeight": 528
      }
    ]
  }
}
```
Note: height is 528 not 500 because macOS outer height includes the ~28px title bar. This gives 500px of usable content area.

Register the `tauri-plugin-dialog` in `src-tauri/src/lib.rs` using `.plugin(tauri_plugin_dialog::init())`.
  </action>
  <verify>
    <automated>cd /Users/darrellwhitelaw/Claude/chatgpt-to-claude && cargo check --manifest-path src-tauri/Cargo.toml 2>&1 | tail -5 && pnpm tsc --noEmit 2>&1 | tail -5</automated>
    <manual>Confirm `cargo check` exits 0 and `pnpm tsc --noEmit` exits 0 with no errors</manual>
  </verify>
  <done>Project compiles: `cargo check` exits 0, `pnpm tsc --noEmit` exits 0, `pnpm dev` starts the app without runtime errors in the console</done>
</task>

<task type="auto">
  <name>Task 2: SQLite schema, AppState, and parse_zip command stub</name>
  <files>
    src-tauri/src/lib.rs
    src-tauri/src/commands/mod.rs
    src-tauri/src/commands/ingest.rs
    src-tauri/src/pipeline/mod.rs
    src-tauri/src/store/mod.rs
    src-tauri/src/store/db.rs
    src-tauri/src/store/schema.sql
    src/lib/bindings.ts
  </files>
  <action>
Create the module structure under `src-tauri/src/`:

**`src-tauri/src/store/schema.sql`** — SQLite schema:
```sql
CREATE TABLE IF NOT EXISTS conversations (
    id TEXT PRIMARY KEY,
    title TEXT,
    created_at INTEGER,
    message_count INTEGER NOT NULL DEFAULT 0,
    has_images INTEGER NOT NULL DEFAULT 0,
    has_code INTEGER NOT NULL DEFAULT 0,
    token_estimate INTEGER NOT NULL DEFAULT 0,
    full_text TEXT NOT NULL DEFAULT '',
    cluster_id TEXT,
    project_name TEXT
);
```

**`src-tauri/src/store/db.rs`** — DB init:
```rust
use rusqlite::{Connection, Result};

pub fn init_schema(conn: &Connection) -> Result<()> {
    conn.execute_batch(include_str!("schema.sql"))
}
```

**`src-tauri/src/store/mod.rs`**:
```rust
pub mod db;
```

**`src-tauri/src/commands/ingest.rs`** — command stub with full IPC signature:
```rust
use serde::{Deserialize, Serialize};
use tauri::ipc::Channel;

#[derive(Clone, Serialize, Deserialize)]
#[serde(rename_all = "camelCase", tag = "event", content = "data")]
pub enum IngestEvent {
    Started,
    ExtractingZip,
    ParsingConversations { processed: u32 },
    BuildingIndex,
    Complete { total: u32, earliest_year: i32, latest_year: i32 },
    Error { message: String },
}

#[tauri::command]
pub async fn parse_zip(
    path: String,
    on_event: Channel<IngestEvent>,
) -> Result<(), String> {
    // Stub — full implementation in plan 01-02
    on_event.send(IngestEvent::Started).map_err(|e| e.to_string())?;
    on_event
        .send(IngestEvent::Complete {
            total: 0,
            earliest_year: 2023,
            latest_year: 2023,
        })
        .map_err(|e| e.to_string())?;
    Ok(())
}
```

**`src-tauri/src/commands/mod.rs`**:
```rust
pub mod ingest;
```

**`src-tauri/src/pipeline/mod.rs`** — empty placeholder (filled in plan 01-02 and 01-03):
```rust
// Pipeline modules added in plans 01-02 and 01-03
```

**`src-tauri/src/lib.rs`** — AppState, DB init in setup, command registration:
```rust
mod commands;
mod pipeline;
mod store;

use rusqlite::Connection;
use std::sync::Mutex;

pub struct AppState {
    pub db: Mutex<Connection>,
}

pub fn run() {
    tauri::Builder::default()
        .setup(|app| {
            let db_path = app
                .path()
                .app_data_dir()
                .expect("failed to get app data dir")
                .join("conversations.db");
            let conn = Connection::open(&db_path)
                .expect("failed to open database");
            store::db::init_schema(&conn)
                .expect("failed to initialize schema");
            app.manage(AppState { db: Mutex::new(conn) });
            Ok(())
        })
        .plugin(tauri_plugin_dialog::init())
        .invoke_handler(tauri::generate_handler![
            commands::ingest::parse_zip,
        ])
        .run(tauri::generate_context!())
        .expect("error while running tauri application");
}
```

**`src/lib/bindings.ts`** — TypeScript types matching the Rust IngestEvent enum:
```typescript
// IPC types — must stay in sync with src-tauri/src/commands/ingest.rs IngestEvent

export type IngestEvent =
  | { event: 'started'; data: never }
  | { event: 'extractingZip'; data: never }
  | { event: 'parsingConversations'; data: { processed: number } }
  | { event: 'buildingIndex'; data: never }
  | { event: 'complete'; data: { total: number; earliestYear: number; latestYear: number } }
  | { event: 'error'; data: { message: string } };

export type ParseZipArgs = {
  path: string;
};
```

CRITICAL: Do NOT call `invoke_handler` twice. All commands go into the single `generate_handler![]` call.
  </action>
  <verify>
    <automated>cd /Users/darrellwhitelaw/Claude/chatgpt-to-claude && cargo check --manifest-path src-tauri/Cargo.toml 2>&1 | grep -E "^error" | head -10; pnpm tsc --noEmit 2>&1 | grep -E "error TS" | head -10</automated>
    <manual>Both commands produce zero lines of output (no errors)</manual>
  </verify>
  <done>
    - `cargo check` passes with no errors
    - `pnpm tsc --noEmit` passes with no errors
    - `src-tauri/src/store/schema.sql` exists and contains the conversations table DDL
    - `src-tauri/src/commands/ingest.rs` exports `parse_zip` and `IngestEvent`
    - `src-tauri/src/lib.rs` manages `AppState` and registers `parse_zip` in a single `generate_handler![]` call
    - `src/lib/bindings.ts` exports `IngestEvent` TypeScript union type
  </done>
</task>

</tasks>

<verification>
Run the following after both tasks complete:

```bash
cd /Users/darrellwhitelaw/Claude/chatgpt-to-claude
cargo check --manifest-path src-tauri/Cargo.toml
pnpm tsc --noEmit
pnpm vitest run 2>/dev/null || echo "no tests yet — expected"
```

All three commands must exit cleanly (the vitest run is expected to report "no test files found" — that is correct for this plan).
</verification>

<success_criteria>
- Tauri project scaffolded with React 19, TypeScript, pnpm, Tailwind CSS v4, shadcn/ui
- Window config: 600x528 (outer), not resizable, centered
- Rust dependencies in Cargo.toml: zip, serde, serde_json, rusqlite (bundled), tauri-plugin-dialog
- Frontend dependencies: zustand, lucide-react, @tauri-apps/plugin-dialog, vitest, shadcn/ui
- SQLite schema initialized on app startup with conversations table
- `parse_zip` command stub registered with `Channel<IngestEvent>` signature
- TypeScript IngestEvent type in `src/lib/bindings.ts` matches Rust enum
- `cargo check` and `pnpm tsc --noEmit` both pass with zero errors
</success_criteria>

<output>
After completion, create `.planning/phases/01-zip-parsing-foundation/01-01-SUMMARY.md` following the summary template.
</output>
