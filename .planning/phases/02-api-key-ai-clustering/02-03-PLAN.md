---
phase: 02-api-key-ai-clustering
plan: "03"
type: execute
wave: 2
depends_on:
  - "02-01"
  - "02-02"
files_modified:
  - src/hooks/useKeychain.ts
  - src/screens/ApiKeyScreen.tsx
  - src/components/SummaryCard.tsx
  - src/App.tsx
autonomous: false
requirements:
  - SEC-01
  - SEC-02

must_haves:
  truths:
    - "User can enter an API key in a password input and click Continue to save it to Keychain"
    - "Invalid or rejected key shows an inline error under the input — no modal, user stays on screen"
    - "First-launch flow: summary card -> Continue -> ApiKeyScreen (when no key in Keychain)"
    - "Returning user flow: summary card -> Continue -> cost screen (key already stored, skips ApiKeyScreen)"
    - "Summary card has a subtle 'Change key' link that takes user back to ApiKeyScreen"
  artifacts:
    - path: "src/hooks/useKeychain.ts"
      provides: "useKeychain hook — get/set/delete API key via Tauri invoke"
      exports: ["useKeychain"]
    - path: "src/screens/ApiKeyScreen.tsx"
      provides: "Password input + inline error + Continue button UI"
      min_lines: 60
    - path: "src/App.tsx"
      provides: "Routing for awaiting-key and key-stored phases"
      contains: "awaiting-key"
  key_links:
    - from: "src/screens/ApiKeyScreen.tsx"
      to: "useKeychain hook"
      via: "import { useKeychain }"
      pattern: "useKeychain"
    - from: "src/App.tsx"
      to: "ApiKeyScreen"
      via: "phase === 'awaiting-key'"
      pattern: "awaiting-key.*ApiKeyScreen"
    - from: "src/components/SummaryCard.tsx"
      to: "onContinue callback"
      via: "onContinue prop called on Continue button click"
      pattern: "onContinue"
---

<objective>
Build the API key entry UI: useKeychain hook, ApiKeyScreen component, SummaryCard "Change key" link, and App.tsx routing for all Phase 2 entry points.

Purpose: This is the user-visible gate into the AI clustering flow. SEC-01 (key in Keychain) and SEC-02 (first-launch UI) are satisfied here.
Output: A complete first-launch and returning-user key entry flow with inline error handling.
</objective>

<execution_context>
@/Users/darrellwhitelaw/.claude/get-shit-done/workflows/execute-plan.md
@/Users/darrellwhitelaw/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-api-key-ai-clustering/02-CONTEXT.md
@.planning/phases/02-api-key-ai-clustering/02-RESEARCH.md
@src/store/appStore.ts
@src/lib/bindings.ts
@src/App.tsx
@src/components/SummaryCard.tsx
@src/hooks/useIngest.ts
@src/components/DropZone.tsx
@.planning/phases/02-api-key-ai-clustering/02-01-SUMMARY.md
@.planning/phases/02-api-key-ai-clustering/02-02-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create useKeychain hook and ApiKeyScreen component</name>
  <files>
    src/hooks/useKeychain.ts
    src/screens/ApiKeyScreen.tsx
  </files>
  <action>
First, create the `src/screens/` directory if it does not exist.

**src/hooks/useKeychain.ts** — thin hook wrapping the three Tauri keychain commands:
```typescript
import { invoke } from '@tauri-apps/api/core';

export function useKeychain() {
  const getApiKey = (): Promise<string> =>
    invoke('get_api_key');

  const setApiKey = (key: string): Promise<void> =>
    invoke('set_api_key', { key });

  const deleteApiKey = (): Promise<void> =>
    invoke('delete_api_key');

  return { getApiKey, setApiKey, deleteApiKey };
}
```

**src/screens/ApiKeyScreen.tsx** — implement per locked decisions in CONTEXT.md:

UI requirements (locked):
- Password-style `<input type="password">` for the key field
- Single label above the input: "Anthropic API key"
- Single "Continue" button — same style as SummaryCard's Continue button (bg-neutral-900 text-white)
- Inline error below the input on failure: "Invalid API key — check console.anthropic.com" in text-red-500
- No modal, no alert — error replaces any previous error inline, user stays on screen
- Visual style: matches DropZone aesthetic — light theme, Inter font, neutral palette, clean minimal

**Key validation flow (Pitfall 3 from RESEARCH.md — critical):**
1. User clicks Continue
2. Set `isLoading = true`, clear previous error
3. Make a test API call FIRST via `invoke('get_cost_estimate', { key })` — but since Plan 02-04 implements that, use a direct `invoke('validate_api_key', { key })` stub OR inline the validation here using `fetch` to `https://api.anthropic.com/v1/messages/count_tokens` with a minimal payload.

ACTUALLY: The cost estimation command (Plan 02-04) isn't available yet. Use this strategy instead:
- Call `invoke('set_api_key', { key })` optimistically (stores in Keychain)
- The cost screen (Plan 02-04) will validate the key by making a real API call. If that fails, Plan 02-04 calls `delete_api_key()` and transitions back with an error. This is acceptable since Keychain write + delete is idempotent.
- For Phase 2 simplicity, do NOT validate at key entry time — Keychain is ephemeral storage, bad key surfaces at cost estimation. User sees "Invalid API key" inline on cost screen instead.

Wait — CONTEXT.md says "Invalid/rejected key shows an inline error under the input field". This means the ApiKeyScreen itself must show the error. Since validation happens at cost-estimate time (the actual API call), the CostScreen flow (Plan 02-04) will need to be able to signal back to ApiKeyScreen.

**Revised flow:**
- ApiKeyScreen takes an optional `initialError?: string` prop (passed from App.tsx when a bad key was detected downstream)
- On Continue: call `setApiKey(key)` then call store action `setKeyStored()` to transition to `key-stored` phase
- If `set_api_key` itself throws (Keychain write error, not API error): show that error inline
- API validation errors surface on the CostScreen and transition back to `awaiting-key` with an error prop

```typescript
interface ApiKeyScreenProps {
  initialError?: string;
}

export function ApiKeyScreen({ initialError }: ApiKeyScreenProps) {
  const [key, setKey] = useState('');
  const [error, setError] = useState<string | null>(initialError ?? null);
  const [isLoading, setIsLoading] = useState(false);
  const { setApiKey } = useKeychain();
  const { setKeyStored } = useAppStore();

  const handleContinue = async () => {
    if (!key.trim()) {
      setError('Enter your Anthropic API key');
      return;
    }
    setIsLoading(true);
    setError(null);
    try {
      await setApiKey(key.trim());
      setKeyStored();
    } catch (err) {
      setError(err instanceof Error ? err.message : 'Failed to save key — try again');
    } finally {
      setIsLoading(false);
    }
  };

  return (
    <div className="flex flex-col items-center gap-6 w-full max-w-sm px-6">
      <div className="flex flex-col gap-1.5 w-full">
        <label className="text-sm text-neutral-600 font-medium">
          Anthropic API key
        </label>
        <input
          type="password"
          value={key}
          onChange={(e) => setKey(e.target.value)}
          onKeyDown={(e) => e.key === 'Enter' && handleContinue()}
          placeholder="sk-ant-..."
          className="w-full px-3 py-2 rounded-lg border border-neutral-200 text-sm
                     focus:outline-none focus:ring-2 focus:ring-neutral-300
                     bg-white text-neutral-800 placeholder-neutral-300"
          autoComplete="off"
          spellCheck={false}
        />
        {error && (
          <p className="text-xs text-red-500 mt-0.5">{error}</p>
        )}
      </div>
      <button
        onClick={handleContinue}
        disabled={isLoading}
        className="px-8 py-2.5 rounded-lg bg-neutral-900 text-white text-sm font-medium
                   hover:bg-neutral-700 transition-colors disabled:opacity-50 disabled:cursor-not-allowed"
      >
        {isLoading ? 'Saving...' : 'Continue'}
      </button>
    </div>
  );
}
```

Import `useState` from 'react', `useKeychain` from '../hooks/useKeychain', `useAppStore` from '../store/appStore'.
  </action>
  <verify>
    <automated>cd /Users/darrellwhitelaw/Claude/chatgpt-to-claude && npx tsc --noEmit 2>&1 | head -20</automated>
    <manual>Confirm ApiKeyScreen.tsx exists in src/screens/. Confirm useKeychain.ts exists in src/hooks/. Confirm tsc passes.</manual>
  </verify>
  <done>
    `npx tsc --noEmit` passes. ApiKeyScreen renders password input, label, Continue button, and inline error slot. useKeychain exposes getApiKey, setApiKey, deleteApiKey.
  </done>
</task>

<task type="auto">
  <name>Task 2: Wire SummaryCard "Change key" link and update App.tsx routing</name>
  <files>
    src/components/SummaryCard.tsx
    src/App.tsx
  </files>
  <action>
**src/components/SummaryCard.tsx** — add two new optional props:
- `onChangeKey?: () => void` — callback for the "Change key" link
- `hasApiKey?: boolean` — controls whether the "Change key" link is visible (only shown when a key exists)

Add a subtle "Change key" link below the Continue button (locked decision: "subtle — not a prominent button, more like a secondary link"):
```tsx
{hasApiKey && onChangeKey && (
  <button
    onClick={onChangeKey}
    className="text-xs text-neutral-400 hover:text-neutral-600 transition-colors underline underline-offset-2"
  >
    Change key
  </button>
)}
```

The existing `onContinue` prop and all other props remain unchanged.

**src/App.tsx** — update with full Phase 2 routing. Read the current App.tsx first, then replace the `onContinue` handler and add new phase renderings:

1. Add import for `useKeychain` and new screens/components:
```typescript
import { useKeychain } from './hooks/useKeychain';
import { ApiKeyScreen } from './screens/ApiKeyScreen';
```

2. Add `useKeychain()` usage inside App component and handle the Continue button on SummaryCard:
```typescript
const { getApiKey } = useKeychain();
const { phase, stage, error, summary, reset, setAwaitingKey, setKeyStored, clusterError } = useAppStore();

const handleSummaryContinue = async () => {
  try {
    await getApiKey(); // succeeds if key exists
    setKeyStored();    // skip ApiKeyScreen, go to cost estimation
  } catch {
    setAwaitingKey();  // no key — show ApiKeyScreen
  }
};
```

3. Update the SummaryCard render to pass the new handler and props:
```tsx
{phase === 'complete' && summary && (
  <SummaryCard
    total={summary.total}
    earliestYear={summary.earliestYear}
    latestYear={summary.latestYear}
    onContinue={handleSummaryContinue}
    hasApiKey={false}  // will be set dynamically via a state check in Plan 02-04
    onChangeKey={() => setAwaitingKey()}
  />
)}
```

4. Add routing for new phases — add below the existing phase renderings:
```tsx
{phase === 'awaiting-key' && (
  <ApiKeyScreen initialError={clusterError ?? undefined} />
)}
{phase === 'key-stored' && (
  // CostScreen renders here — Plan 02-04 adds this
  <ProgressView stage="Counting tokens..." />
)}
{phase === 'cost-ready' && (
  // CostScreen renders here — Plan 02-04 replaces this placeholder
  <ProgressView stage="Ready to cluster" />
)}
{phase === 'clustering' && (
  // ClusteringView renders here — Plan 02-05 replaces this placeholder
  <ProgressView stage={stage} />
)}
{phase === 'clustering-complete' && (
  // Phase 3 entry point — placeholder
  <ProgressView stage="Clustering complete" />
)}
```

Note: `key-stored`, `cost-ready`, and `clustering` show ProgressView as a placeholder — Plans 02-04 and 02-05 will replace these with real screens. This approach lets each plan compile and type-check without blocking on later plans.

Also update the `hasApiKey` prop: for now, set `hasApiKey={false}` as a placeholder (the actual Keychain check happens in `handleSummaryContinue`; the "Change key" link is shown only after clustering starts). Plan 02-04 will update this to `hasApiKey={true}` for the post-key-entry state.
  </action>
  <verify>
    <automated>cd /Users/darrellwhitelaw/Claude/chatgpt-to-claude && npx tsc --noEmit 2>&1 | head -20</automated>
    <manual>Confirm App.tsx handles all 8 AppPhase values without TypeScript exhaustiveness errors. Confirm SummaryCard.tsx has onChangeKey and hasApiKey props.</manual>
  </verify>
  <done>
    `npx tsc --noEmit` passes. App.tsx routes all Phase 2 phases. SummaryCard has subtle "Change key" link controlled by hasApiKey prop. handleSummaryContinue calls getApiKey() to gate on Keychain presence.
  </done>
</task>

<task type="checkpoint:human-verify" gate="blocking">
  <name>Checkpoint: Verify API key entry and first-launch flow</name>
  <action>Verify API key entry and first-launch detection flow work correctly in the running app.</action>
  <what-built>
    Complete API key entry flow:
    - SummaryCard Continue button now calls Keychain to decide whether to show ApiKeyScreen
    - ApiKeyScreen with password input, inline error slot, and Continue button
    - "Change key" subtle link on SummaryCard (controlled by hasApiKey prop)
    - App.tsx routing for all 8 AppPhase values (Phase 2 screens use ProgressView placeholders)
  </what-built>
  <how-to-verify>
    1. Run `cd /Users/darrellwhitelaw/Claude/chatgpt-to-claude && npm run dev` (or `pnpm dev`)
    2. Drop the ChatGPT export ZIP to get to the summary card ("Found N conversations")
    3. Click Continue — on first launch (no Keychain entry), ApiKeyScreen should appear
    4. Type a fake key (e.g. "sk-ant-test") and click Continue — should transition to key-stored phase (showing "Counting tokens..." progress placeholder)
    5. Go back to the summary card (reset app, re-drop ZIP), click Continue again — this time it should skip ApiKeyScreen and go directly to key-stored phase
    6. Verify the password input masks characters as you type
    7. Verify pressing Enter in the input field triggers Continue
  </how-to-verify>
  <resume-signal>Type "approved" if the flow works correctly, or describe any issues to fix</resume-signal>
</task>

</tasks>

<verification>
TypeScript check: `cd /Users/darrellwhitelaw/Claude/chatgpt-to-claude && npx tsc --noEmit` — exits 0.

All AppPhase variants handled in App.tsx without TypeScript errors.
ApiKeyScreen in src/screens/ApiKeyScreen.tsx, useKeychain in src/hooks/useKeychain.ts.
</verification>

<success_criteria>
- `npx tsc --noEmit` passes with no errors
- ApiKeyScreen shows password input, label, Continue button, inline error slot — no modal
- First-launch: Continue on summary card → ApiKeyScreen
- Returning user (key in Keychain): Continue on summary card → key-stored phase (skips ApiKeyScreen)
- "Change key" link on summary card transitions to awaiting-key
- Enter key in password input triggers Continue
- All 8 AppPhase variants routed in App.tsx
- Human checkpoint approved
</success_criteria>

<output>
After completion, create `.planning/phases/02-api-key-ai-clustering/02-03-SUMMARY.md`
</output>
