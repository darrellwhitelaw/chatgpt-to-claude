---
phase: 02-api-key-ai-clustering
plan: "01"
type: execute
wave: 1
depends_on: []
files_modified:
  - src-tauri/Cargo.toml
  - src-tauri/src/commands/keychain.rs
  - src-tauri/src/commands/mod.rs
  - src-tauri/src/store/schema.sql
  - src-tauri/src/store/db.rs
  - src-tauri/src/lib.rs
autonomous: true
requirements:
  - SEC-01
  - SEC-02

must_haves:
  truths:
    - "API key can be stored in macOS Keychain without touching disk or app state"
    - "First-launch `get_api_key` returns a distinguishable NoEntry error (not a panic)"
    - "SQLite schema includes cluster_label, summary, and instructions columns"
    - "Keychain commands are registered in the invoke_handler and callable from the frontend"
  artifacts:
    - path: "src-tauri/src/commands/keychain.rs"
      provides: "get_api_key, set_api_key, delete_api_key Tauri commands"
      exports: ["get_api_key", "set_api_key", "delete_api_key"]
    - path: "src-tauri/src/store/schema.sql"
      provides: "Extended conversations schema with Phase 2 columns"
      contains: "cluster_label TEXT"
    - path: "src-tauri/src/store/db.rs"
      provides: "update_cluster_result() helper writing cluster_label, summary, instructions"
  key_links:
    - from: "src-tauri/src/lib.rs"
      to: "commands::keychain::get_api_key"
      via: "tauri::generate_handler!"
      pattern: "generate_handler!\\[.*get_api_key"
    - from: "src-tauri/src/store/db.rs"
      to: "conversations table"
      via: "UPDATE with cluster_label, summary, instructions"
      pattern: "cluster_label.*summary.*instructions"
---

<objective>
Add the Rust backend for Phase 2: macOS Keychain integration and SQLite schema extension.

Purpose: Every subsequent Phase 2 plan depends on these foundations. Keychain commands must be registered before the frontend can call them. Schema columns must exist before batch results can be written.
Output: Three Tauri commands (get/set/delete API key), extended schema.sql, db.rs update helper, Cargo.toml with keyring and reqwest.
</objective>

<execution_context>
@/Users/darrellwhitelaw/.claude/get-shit-done/workflows/execute-plan.md
@/Users/darrellwhitelaw/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-api-key-ai-clustering/02-RESEARCH.md
@src-tauri/Cargo.toml
@src-tauri/src/lib.rs
@src-tauri/src/commands/mod.rs
@src-tauri/src/store/schema.sql
@src-tauri/src/store/db.rs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add keyring + reqwest to Cargo.toml and create keychain.rs commands</name>
  <files>
    src-tauri/Cargo.toml
    src-tauri/src/commands/keychain.rs
    src-tauri/src/commands/mod.rs
  </files>
  <action>
**Cargo.toml** — add two dependencies under `[dependencies]`:
```toml
keyring = { version = "3", features = ["apple-native"] }
reqwest = { version = "0.12", features = ["json", "rustls-tls"], default-features = false }
```
CRITICAL: `apple-native` feature is mandatory — without it, keyring silently uses the wrong backend on macOS (Pitfall 6 from RESEARCH.md). `default-features = false` is required for `reqwest` to avoid bundling OpenSSL.

**src-tauri/src/commands/keychain.rs** — create this file with exactly three Tauri commands:
```rust
use keyring::Entry;

const SERVICE: &str = "com.darrellwhitelaw.chatgpt-to-claude";
const USER: &str = "anthropic-api-key";

#[tauri::command]
pub fn get_api_key() -> Result<String, String> {
    let entry = Entry::new(SERVICE, USER).map_err(|e| e.to_string())?;
    entry.get_password().map_err(|e| e.to_string())
}

#[tauri::command]
pub fn set_api_key(key: String) -> Result<(), String> {
    let entry = Entry::new(SERVICE, USER).map_err(|e| e.to_string())?;
    entry.set_password(&key).map_err(|e| e.to_string())
}

#[tauri::command]
pub fn delete_api_key() -> Result<(), String> {
    let entry = Entry::new(SERVICE, USER).map_err(|e| e.to_string())?;
    entry.delete_credential().map_err(|e| e.to_string())
}
```

**Error handling note:** `get_api_key()` returns `Err("No matching entry found in secure storage")` when no key exists on first launch. This is NOT a panic — it is the normal first-launch signal that React will use to transition to the `awaiting-key` AppPhase. Do NOT unwrap or panic on this error in Rust.

**src-tauri/src/commands/mod.rs** — add `pub mod keychain;` alongside the existing `pub mod ingest;`.

**src-tauri/src/lib.rs** — register the three new commands in `tauri::generate_handler![]`:
```rust
commands::keychain::get_api_key,
commands::keychain::set_api_key,
commands::keychain::delete_api_key,
```
Add them alongside `commands::ingest::parse_zip`.
  </action>
  <verify>
    <automated>cd /Users/darrellwhitelaw/Claude/chatgpt-to-claude/src-tauri && cargo check 2>&1 | tail -5</automated>
    <manual>Confirm `cargo check` exits 0 with no errors. Warnings about unused imports are acceptable at this stage.</manual>
  </verify>
  <done>
    `cargo check` passes. keychain.rs compiles. lib.rs registers all three keychain commands. Cargo.toml contains keyring with apple-native and reqwest with rustls-tls.
  </done>
</task>

<task type="auto">
  <name>Task 2: Extend SQLite schema and add update_cluster_result() DB helper</name>
  <files>
    src-tauri/src/store/schema.sql
    src-tauri/src/store/db.rs
  </files>
  <action>
**src-tauri/src/store/schema.sql** — replace the existing CREATE TABLE statement with an extended version that includes the three new Phase 2 columns. The schema uses `CREATE TABLE IF NOT EXISTS` so the full column list must be present from the start — rusqlite does not support `ALTER TABLE ... ADD COLUMN IF NOT EXISTS`. Add `cluster_label TEXT`, `summary TEXT`, and `instructions TEXT` after the existing `project_name TEXT` column:

```sql
CREATE TABLE IF NOT EXISTS conversations (
    id TEXT PRIMARY KEY,
    title TEXT,
    created_at INTEGER,
    message_count INTEGER NOT NULL DEFAULT 0,
    has_images INTEGER NOT NULL DEFAULT 0,
    has_code INTEGER NOT NULL DEFAULT 0,
    token_estimate INTEGER NOT NULL DEFAULT 0,
    full_text TEXT NOT NULL DEFAULT '',
    cluster_id TEXT,
    project_name TEXT,
    cluster_label TEXT,
    summary TEXT,
    instructions TEXT
);
```

IMPORTANT: Because `CREATE TABLE IF NOT EXISTS` only runs once on a fresh DB, existing dev databases will NOT have these columns automatically. For development, delete the existing `conversations.db` in the app data directory (`~/Library/Application Support/com.darrellwhitelaw.chatgpt-to-claude/conversations.db`) so the schema initializes fresh. Do NOT add a migration for now — this is a dev-only concern before v1 ships.

**src-tauri/src/store/db.rs** — add a new public function `update_cluster_result` that writes the three Phase 2 fields for a single conversation. Read the existing `db.rs` first to understand the current function signatures and Connection import pattern, then append:

```rust
pub fn update_cluster_result(
    conn: &rusqlite::Connection,
    conversation_id: &str,
    cluster_label: &str,
    summary: &str,
    instructions: Option<&str>,
) -> rusqlite::Result<()> {
    conn.execute(
        "UPDATE conversations SET cluster_label = ?1, summary = ?2, instructions = ?3 WHERE id = ?4",
        rusqlite::params![cluster_label, summary, instructions, conversation_id],
    )?;
    Ok(())
}
```

Also add a helper to fetch all conversations for batch building — Plan 02-05 will need this:

```rust
pub struct ConversationRow {
    pub id: String,
    pub title: Option<String>,
    pub full_text: String,
    pub token_estimate: i64,
}

pub fn get_all_conversations(conn: &rusqlite::Connection) -> rusqlite::Result<Vec<ConversationRow>> {
    let mut stmt = conn.prepare(
        "SELECT id, title, full_text, token_estimate FROM conversations ORDER BY created_at ASC"
    )?;
    let rows = stmt.query_map([], |row| {
        Ok(ConversationRow {
            id: row.get(0)?,
            title: row.get(1)?,
            full_text: row.get(2)?,
            token_estimate: row.get(3)?,
        })
    })?;
    rows.collect()
}
```
  </action>
  <verify>
    <automated>cd /Users/darrellwhitelaw/Claude/chatgpt-to-claude/src-tauri && cargo check 2>&1 | tail -5</automated>
    <manual>Confirm schema.sql contains cluster_label, summary, instructions columns. Confirm db.rs exports update_cluster_result and get_all_conversations.</manual>
  </verify>
  <done>
    `cargo check` passes. schema.sql has all 13 columns. db.rs has `update_cluster_result` and `get_all_conversations` with correct signatures. `ConversationRow` struct is pub.
  </done>
</task>

</tasks>

<verification>
Run full cargo check from src-tauri root: `cd /Users/darrellwhitelaw/Claude/chatgpt-to-claude/src-tauri && cargo check`

Expected: exits 0, no errors. Warnings acceptable.

Grep checks:
- `grep -n "keyring" /Users/darrellwhitelaw/Claude/chatgpt-to-claude/src-tauri/Cargo.toml` → shows `keyring = { version = "3", features = ["apple-native"] }`
- `grep -n "cluster_label" /Users/darrellwhitelaw/Claude/chatgpt-to-claude/src-tauri/src/store/schema.sql` → shows cluster_label column
- `grep -n "get_api_key\|set_api_key\|delete_api_key" /Users/darrellwhitelaw/Claude/chatgpt-to-claude/src-tauri/src/lib.rs` → shows all three in generate_handler!
</verification>

<success_criteria>
- `cargo check` passes with no errors
- keychain.rs has three Tauri commands using SERVICE = "com.darrellwhitelaw.chatgpt-to-claude"
- All three commands registered in lib.rs generate_handler!
- schema.sql has cluster_label, summary, instructions columns
- db.rs has update_cluster_result() and get_all_conversations() with correct types
- reqwest with rustls-tls and keyring with apple-native in Cargo.toml
</success_criteria>

<output>
After completion, create `.planning/phases/02-api-key-ai-clustering/02-01-SUMMARY.md`
</output>
