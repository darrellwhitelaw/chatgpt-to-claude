---
phase: 02-api-key-ai-clustering
plan: "02"
type: execute
wave: 1
depends_on: []
files_modified:
  - src/store/appStore.ts
  - src/lib/bindings.ts
autonomous: true
requirements:
  - SEC-02
  - AI-01

must_haves:
  truths:
    - "AppPhase union covers all Phase 2 states so App.tsx can route to the correct screen"
    - "ClusterEvent type is defined in TypeScript and matches the Rust event structure Plan 02-05 will emit"
    - "AppStore has tokenEstimate, costEstimateUsd, batchId, clusterError fields for Phase 2 UI"
  artifacts:
    - path: "src/store/appStore.ts"
      provides: "Extended AppPhase and AppState with Phase 2 variants"
      contains: "awaiting-key"
    - path: "src/lib/bindings.ts"
      provides: "ClusterEvent type for IPC"
      contains: "ClusterEvent"
  key_links:
    - from: "src/store/appStore.ts"
      to: "AppPhase type"
      via: "export type AppPhase"
      pattern: "awaiting-key.*key-stored.*cost-ready.*clustering"
    - from: "src/lib/bindings.ts"
      to: "ClusterEvent union"
      via: "export type ClusterEvent"
      pattern: "batchSubmitted.*polling.*complete"
---

<objective>
Extend the TypeScript type layer for Phase 2: new AppPhase variants, AppStore fields, and ClusterEvent IPC bindings.

Purpose: All Phase 2 React screens (ApiKeyScreen, CostScreen, ClusteringView) depend on these types. This plan runs in Wave 1 alongside 02-01 (pure Rust) since there is no cross-dependency.
Output: appStore.ts with 6 new phase variants + 4 new state fields; bindings.ts with ClusterEvent type.
</objective>

<execution_context>
@/Users/darrellwhitelaw/.claude/get-shit-done/workflows/execute-plan.md
@/Users/darrellwhitelaw/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-api-key-ai-clustering/02-RESEARCH.md
@src/store/appStore.ts
@src/lib/bindings.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Extend AppPhase, AppState, and store actions in appStore.ts</name>
  <files>
    src/store/appStore.ts
  </files>
  <action>
Replace the contents of `src/store/appStore.ts` entirely. Preserve all existing Phase 1 types and actions, then add Phase 2 variants and fields.

**New AppPhase union** — extend from the current `'idle' | 'parsing' | 'complete' | 'error'` to include all Phase 2 states:
```typescript
export type AppPhase =
  | 'idle'
  | 'parsing'
  | 'complete'             // Phase 1: summary card shown
  | 'awaiting-key'         // Phase 2: no API key in Keychain — show ApiKeyScreen
  | 'key-stored'           // Phase 2: key confirmed valid — ready to fetch cost
  | 'cost-ready'           // Phase 2: token count returned — show CostScreen with Proceed/Cancel
  | 'clustering'           // Phase 2: batch submitted, polling active — show ClusteringView
  | 'clustering-complete'  // Phase 2: batch done, SQLite written — ready for Phase 3
  | 'error';
```

**New AppState fields** — add these four fields to the interface alongside the existing `phase`, `stage`, `error`, `summary` fields:
```typescript
tokenEstimate: number | null;      // exact count from /v1/messages/count_tokens
costEstimateUsd: number | null;    // computed cost in USD
batchId: string | null;            // Anthropic batch ID from submission
clusterError: string | null;       // error message for clustering failure screen
```

**New actions** — add these alongside existing `setStage`, `setError`, `setComplete`, `reset`:
```typescript
setAwaitingKey: () => void;
setKeyStored: () => void;
setCostReady: (tokenEstimate: number, costEstimateUsd: number) => void;
setClustering: (batchId: string) => void;
setClusteringComplete: () => void;
setClusterError: (msg: string) => void;
```

**Implementations** in the `create` call:
```typescript
setAwaitingKey: () => set({ phase: 'awaiting-key' }),
setKeyStored: () => set({ phase: 'key-stored' }),
setCostReady: (tokenEstimate, costEstimateUsd) =>
  set({ phase: 'cost-ready', tokenEstimate, costEstimateUsd }),
setClustering: (batchId) => set({ phase: 'clustering', batchId }),
setClusteringComplete: () => set({ phase: 'clustering-complete' }),
setClusterError: (msg) => set({ phase: 'error', clusterError: msg }),
```

**Initial state additions**:
```typescript
tokenEstimate: null,
costEstimateUsd: null,
batchId: null,
clusterError: null,
```

**Preserve `reset`** — extend it to also clear the four new fields:
```typescript
reset: () => set({
  phase: 'idle', stage: '', error: null, summary: null,
  tokenEstimate: null, costEstimateUsd: null, batchId: null, clusterError: null
}),
```
  </action>
  <verify>
    <automated>cd /Users/darrellwhitelaw/Claude/chatgpt-to-claude && npx tsc --noEmit 2>&1 | head -20</automated>
    <manual>Confirm tsc exits 0. Confirm appStore.ts exports AppPhase with 'awaiting-key' variant.</manual>
  </verify>
  <done>
    `npx tsc --noEmit` passes. AppPhase has all 8 variants. AppState has tokenEstimate, costEstimateUsd, batchId, clusterError. All 6 new actions are implemented.
  </done>
</task>

<task type="auto">
  <name>Task 2: Add ClusterEvent type to bindings.ts</name>
  <files>
    src/lib/bindings.ts
  </files>
  <action>
Append the `ClusterEvent` type to the existing `src/lib/bindings.ts` file. Do NOT modify the existing `IngestEvent` or `ParseZipArgs` types.

Add after the existing exports:

```typescript
// ClusterEvent — must stay in sync with src-tauri/src/commands/cluster.rs ClusterEvent
// These events are emitted via Channel<ClusterEvent> during the clustering pipeline
export type ClusterEvent =
  | { event: 'estimatingTokens' }
  | { event: 'tokensCounted'; data: { tokens: number; estimatedUsd: number } }
  | { event: 'pass1Started' }
  | { event: 'pass1Complete'; data: { clusterLabels: string[] } }
  | { event: 'batchSubmitted'; data: { batchId: string } }
  | { event: 'polling'; data: { elapsedSecs: number } }
  | { event: 'complete'; data: { assignedCount: number } }
  | { event: 'error'; data: { message: string } };
```

**Why these events:**
- `estimatingTokens` — triggers "Counting tokens..." stage label in ClusteringView
- `tokensCounted` — triggers transition to cost-ready phase with actual numbers
- `pass1Started` / `pass1Complete` — for future progress detail (and testability); pass1 generates cluster vocabulary
- `batchSubmitted` — records batch ID in store
- `polling` — shows elapsed time in spinner UI
- `complete` — transitions to clustering-complete
- `error` — transitions to error screen

Also add the args type for the cluster command (Plan 02-05 will implement the Rust side):
```typescript
export type StartClusteringArgs = {
  // No args needed — cluster command reads from SQLite and Keychain internally
};
```
  </action>
  <verify>
    <automated>cd /Users/darrellwhitelaw/Claude/chatgpt-to-claude && npx tsc --noEmit 2>&1 | head -20</automated>
    <manual>Confirm bindings.ts has ClusterEvent type with all 8 variants. Confirm tsc still passes.</manual>
  </verify>
  <done>
    `npx tsc --noEmit` passes. bindings.ts exports ClusterEvent and StartClusteringArgs. Original IngestEvent and ParseZipArgs are unchanged.
  </done>
</task>

</tasks>

<verification>
Run TypeScript check: `cd /Users/darrellwhitelaw/Claude/chatgpt-to-claude && npx tsc --noEmit`

Expected: exits 0, no type errors.

Spot checks:
- `grep -n "awaiting-key" /Users/darrellwhitelaw/Claude/chatgpt-to-claude/src/store/appStore.ts` → shows AppPhase variant
- `grep -n "ClusterEvent" /Users/darrellwhitelaw/Claude/chatgpt-to-claude/src/lib/bindings.ts` → shows type export
- `grep -n "tokenEstimate" /Users/darrellwhitelaw/Claude/chatgpt-to-claude/src/store/appStore.ts` → shows field and initial null value
</verification>

<success_criteria>
- `npx tsc --noEmit` passes with no errors
- AppPhase has 8 variants including all Phase 2 states
- AppState has tokenEstimate, costEstimateUsd, batchId, clusterError
- 6 new store actions are defined and implemented
- ClusterEvent has 8 variants matching the planned Rust events
- All existing Phase 1 types and actions are unchanged
</success_criteria>

<output>
After completion, create `.planning/phases/02-api-key-ai-clustering/02-02-SUMMARY.md`
</output>
