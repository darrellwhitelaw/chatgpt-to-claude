---
phase: 02-api-key-ai-clustering
plan: "04"
type: execute
wave: 3
depends_on:
  - "02-01"
  - "02-02"
  - "02-03"
files_modified:
  - src-tauri/src/commands/cluster.rs
  - src-tauri/src/commands/mod.rs
  - src-tauri/src/lib.rs
  - src/screens/CostScreen.tsx
  - src/hooks/useCluster.ts
  - src/App.tsx
autonomous: false
requirements:
  - AI-02

must_haves:
  truths:
    - "App calls /v1/messages/count_tokens and shows exact token count and USD estimate before any batch is submitted"
    - "CostScreen displays token count + dollar amount in the format '~2.4M tokens · estimated $1.20'"
    - "Warning callout appears when estimated cost exceeds $3.00"
    - "Proceed button transitions to clustering phase; Cancel returns to summary card"
    - "Bad API key detected at this stage: Keychain entry deleted and user returned to ApiKeyScreen with inline error"
  artifacts:
    - path: "src-tauri/src/commands/cluster.rs"
      provides: "estimate_cost Tauri command calling /v1/messages/count_tokens"
      exports: ["estimate_cost"]
    - path: "src/screens/CostScreen.tsx"
      provides: "Token count display + Proceed/Cancel UI"
      min_lines: 60
    - path: "src/hooks/useCluster.ts"
      provides: "useCostEstimate hook wrapping estimate_cost invoke"
      exports: ["useCluster"]
  key_links:
    - from: "src/screens/CostScreen.tsx"
      to: "useCluster hook"
      via: "import { useCluster }"
      pattern: "useCluster"
    - from: "src-tauri/src/commands/cluster.rs"
      to: "https://api.anthropic.com/v1/messages/count_tokens"
      via: "reqwest POST"
      pattern: "count_tokens"
    - from: "src/App.tsx"
      to: "CostScreen"
      via: "phase === 'cost-ready'"
      pattern: "cost-ready.*CostScreen"
---

<objective>
Build the cost estimation screen: Rust command calling /v1/messages/count_tokens, CostScreen UI with token count + dollar estimate, Proceed/Cancel flow, and bad-key handling.

Purpose: AI-02 (show cost before submission). This plan runs in Wave 3 after 02-03 completes — it modifies App.tsx which 02-03 also modified, so it must run sequentially after 02-03.
Output: estimate_cost Tauri command, CostScreen React component, useCluster hook (cost estimation half), App.tsx cost-ready routing.
</objective>

<execution_context>
@/Users/darrellwhitelaw/.claude/get-shit-done/workflows/execute-plan.md
@/Users/darrellwhitelaw/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-api-key-ai-clustering/02-CONTEXT.md
@.planning/phases/02-api-key-ai-clustering/02-RESEARCH.md
@src-tauri/src/lib.rs
@src-tauri/src/commands/mod.rs
@src-tauri/src/store/db.rs
@src/store/appStore.ts
@src/lib/bindings.ts
@src/App.tsx
@.planning/phases/02-api-key-ai-clustering/02-01-SUMMARY.md
@.planning/phases/02-api-key-ai-clustering/02-02-SUMMARY.md
@.planning/phases/02-api-key-ai-clustering/02-03-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create estimate_cost Tauri command in cluster.rs</name>
  <files>
    src-tauri/src/commands/cluster.rs
    src-tauri/src/commands/mod.rs
    src-tauri/src/lib.rs
  </files>
  <action>
**src-tauri/src/commands/cluster.rs** — create this file with the `estimate_cost` async Tauri command.

This command:
1. Reads the API key from Keychain (calls keychain::get_api_key equivalent inline — do NOT store key in state)
2. Fetches all conversations from SQLite using `store::db::get_all_conversations()`
3. Concatenates all `full_text` values (truncated at 8,000 chars each — Pitfall 4 prevention)
4. POSTs to `https://api.anthropic.com/v1/messages/count_tokens` using `reqwest`
5. Computes cost and returns `{ input_tokens, estimated_usd }` on success
6. On 401 from Anthropic: deletes the Keychain entry and returns a distinct error type so the frontend can show the inline error on ApiKeyScreen

```rust
use keyring::Entry;
use serde::{Deserialize, Serialize};
use tauri::State;
use crate::AppState;
use crate::store::db;

const SERVICE: &str = "com.darrellwhitelaw.chatgpt-to-claude";
const USER: &str = "anthropic-api-key";
const MODEL: &str = "claude-haiku-3-5-20241022";
const CLUSTERING_SYSTEM_PROMPT: &str =
    "You are a conversation analyst. Analyze the following ChatGPT conversation \
     transcript and return a JSON object with fields: cluster_label (string), \
     summary (string, 3-5 sentences), instructions (string or null).";

// Full text truncation — prevent 256MB batch limit (Pitfall 4)
const MAX_FULL_TEXT_CHARS: usize = 8_000;

#[derive(Serialize)]
pub struct CostEstimate {
    pub input_tokens: u64,
    pub estimated_usd: f64,
}

#[tauri::command]
pub async fn estimate_cost(state: State<'_, AppState>) -> Result<CostEstimate, String> {
    // 1. Get API key from Keychain
    let entry = Entry::new(SERVICE, USER).map_err(|e| e.to_string())?;
    let api_key = entry.get_password().map_err(|e| e.to_string())?;

    // 2. Fetch all conversations
    let conversations = {
        let conn = state.db.lock().map_err(|e| e.to_string())?;
        db::get_all_conversations(&conn).map_err(|e| e.to_string())?
    };

    let conversation_count = conversations.len() as u64;

    // 3. Concatenate full_text (truncated per conversation)
    let all_text: String = conversations
        .iter()
        .map(|c| {
            let text = &c.full_text;
            if text.len() > MAX_FULL_TEXT_CHARS {
                &text[..MAX_FULL_TEXT_CHARS]
            } else {
                text.as_str()
            }
        })
        .collect::<Vec<_>>()
        .join("\n\n---\n\n");

    // 4. Call count_tokens endpoint
    let client = reqwest::Client::new();
    let response = client
        .post("https://api.anthropic.com/v1/messages/count_tokens")
        .header("x-api-key", &api_key)
        .header("anthropic-version", "2023-06-01")
        .header("content-type", "application/json")
        .json(&serde_json::json!({
            "model": MODEL,
            "system": CLUSTERING_SYSTEM_PROMPT,
            "messages": [{"role": "user", "content": all_text}]
        }))
        .send()
        .await
        .map_err(|e| e.to_string())?;

    // Handle 401 — bad key: delete from Keychain, return special error
    if response.status() == 401 {
        let _ = entry.delete_credential(); // best-effort — don't fail if already gone
        return Err("INVALID_API_KEY: Invalid API key — check console.anthropic.com".to_string());
    }

    if !response.status().is_success() {
        let status = response.status();
        let body = response.text().await.unwrap_or_default();
        return Err(format!("API error {}: {}", status, body));
    }

    let body: serde_json::Value = response.json().await.map_err(|e| e.to_string())?;
    let input_tokens = body["input_tokens"].as_u64().unwrap_or(0);

    // 5. Compute cost — haiku-3-5 batch pricing (source: RESEARCH.md)
    // input: $0.40/MTok, output: $2.00/MTok, estimated ~300 output tokens/conversation
    let input_cost = (input_tokens as f64 * 0.40) / 1_000_000.0;
    let output_cost = (conversation_count as f64 * 300.0 * 2.00) / 1_000_000.0;
    let estimated_usd = input_cost + output_cost;

    Ok(CostEstimate { input_tokens, estimated_usd })
}
```

**src-tauri/src/commands/mod.rs** — add `pub mod cluster;` alongside existing modules.

**src-tauri/src/lib.rs** — register `estimate_cost` in `tauri::generate_handler![]`. Also add `reqwest` and `serde_json` usage at module level (they should already be pulled in via Cargo.toml from Plan 02-01, but confirm the generate_handler registration):
```rust
commands::cluster::estimate_cost,
```

Note: `estimate_cost` is `async fn` — Tauri 2 handles async commands natively without any special wrapping. Use `#[tauri::command]` on `async fn` directly. Do NOT use `tauri::async_runtime::spawn` inside a Tauri async command (the command IS the async context).
  </action>
  <verify>
    <automated>cd /Users/darrellwhitelaw/Claude/chatgpt-to-claude/src-tauri && cargo check 2>&1 | tail -10</automated>
    <manual>Confirm cargo check passes. Confirm cluster.rs exports estimate_cost. Confirm lib.rs has estimate_cost in generate_handler!.</manual>
  </verify>
  <done>
    `cargo check` passes. cluster.rs has estimate_cost async command. 401 handling deletes Keychain entry and returns "INVALID_API_KEY:" prefixed error. Cost formula uses $0.40/$2.00 per MTok at haiku-3-5 batch pricing.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create CostScreen component and useCluster hook; update App.tsx</name>
  <files>
    src/screens/CostScreen.tsx
    src/hooks/useCluster.ts
    src/App.tsx
  </files>
  <action>
**src/hooks/useCluster.ts** — create hook that wraps `estimate_cost` and handles the bad-key error:

```typescript
import { invoke } from '@tauri-apps/api/core';
import { useAppStore } from '../store/appStore';

interface CostEstimate {
  input_tokens: number;
  estimated_usd: number;
}

export function useCluster() {
  const { setCostReady, setAwaitingKey } = useAppStore();

  const fetchCostEstimate = async (): Promise<void> => {
    try {
      const result: CostEstimate = await invoke('estimate_cost');
      setCostReady(result.input_tokens, result.estimated_usd);
    } catch (err) {
      const msg = err instanceof Error ? err.message : String(err);
      if (msg.startsWith('INVALID_API_KEY:')) {
        // Bad key — Keychain already cleared by Rust; show ApiKeyScreen with error
        // Use the store's clusterError field to pass the error message to ApiKeyScreen
        useAppStore.getState().setClusterError('Invalid API key — check console.anthropic.com');
        setAwaitingKey();
      } else {
        useAppStore.getState().setClusterError(msg);
        useAppStore.getState().setError(msg); // also set general error for error screen
      }
    }
  };

  return { fetchCostEstimate };
}
```

**src/screens/CostScreen.tsx** — implement per locked decisions:

UI requirements (locked):
- Display: `"{formatTokens(tokens)} tokens · estimated ${estimatedUsd.toFixed(2)}"` — single `<p>` element with middot separator (per CONTEXT.md: "~2.4M tokens · estimated $1.20")
- Two buttons: "Proceed" (bg-neutral-900 text-white) and "Cancel" (text-neutral-500 underline link style)
- Cancel returns to summary card (calls `useAppStore.setState({ phase: 'complete' })` directly — Zustand allows direct setState)
- Warning callout when `estimatedUsd > 3.00` (threshold from RESEARCH.md discretion): amber/yellow callout block: "This is higher than typical — your export is large." Non-alarming per CONTEXT.md
- Proceed triggers clustering (Plan 02-05 implements the actual batch logic — for now, transition to `clustering` phase)

```typescript
import { useAppStore } from '../store/appStore';

interface CostScreenProps {
  tokens: number;
  estimatedUsd: number;
}

export function CostScreen({ tokens, estimatedUsd }: CostScreenProps) {
  const { setClustering } = useAppStore();

  const formatTokens = (n: number): string => {
    if (n >= 1_000_000) return `~${(n / 1_000_000).toFixed(1)}M`;
    if (n >= 1_000) return `~${Math.round(n / 1_000)}K`;
    return `${n}`;
  };

  const handleProceed = () => {
    // Plan 02-05 will invoke the actual batch command here.
    // For now, transition phase to trigger ClusteringView placeholder.
    setClustering('pending'); // placeholder batchId — replaced in 02-05
  };

  const handleCancel = () => {
    // Return to summary card — phase is 'complete' with summary still in store
    useAppStore.setState({ phase: 'complete' });
  };

  const HIGH_COST_THRESHOLD = 3.00;

  return (
    <div className="flex flex-col items-center gap-6 w-full max-w-sm px-6 text-center">
      {/* Token + cost estimate — single line with middot separator (locked decision) */}
      <p className="text-2xl font-medium text-neutral-800">
        {formatTokens(tokens)} tokens · estimated ${estimatedUsd.toFixed(2)}
      </p>

      {/* High-cost warning (> $3.00) */}
      {estimatedUsd > HIGH_COST_THRESHOLD && (
        <div className="w-full rounded-lg bg-amber-50 border border-amber-200 px-4 py-3">
          <p className="text-sm text-amber-700">
            This is higher than typical — your export is large.
          </p>
        </div>
      )}

      {/* Actions */}
      <div className="flex flex-col items-center gap-3 w-full">
        <button
          onClick={handleProceed}
          className="w-full px-8 py-2.5 rounded-lg bg-neutral-900 text-white text-sm font-medium
                     hover:bg-neutral-700 transition-colors"
        >
          Proceed
        </button>
        <button
          onClick={handleCancel}
          className="text-sm text-neutral-400 hover:text-neutral-600 transition-colors underline underline-offset-2"
        >
          Cancel
        </button>
      </div>
    </div>
  );
}
```

**src/App.tsx** — make two targeted updates:

1. Add imports for CostScreen and useCluster:
```typescript
import { CostScreen } from './screens/CostScreen';
import { useCluster } from './hooks/useCluster';
```

2. In the App component, add `fetchCostEstimate` from `useCluster()`. When `phase === 'key-stored'`, trigger cost estimation automatically on mount:
```tsx
// Replace the 'key-stored' placeholder:
{phase === 'key-stored' && (
  <KeyStoredLoader onLoad={fetchCostEstimate} />
)}
```

Create a tiny inline component or use `useEffect` in App:
```tsx
// Simpler: use a useEffect triggered by phase transition
useEffect(() => {
  if (phase === 'key-stored') {
    fetchCostEstimate();
  }
}, [phase]); // eslint-disable-line react-hooks/exhaustive-deps
```

3. Replace the `cost-ready` placeholder:
```tsx
{phase === 'cost-ready' && tokenEstimate !== null && costEstimateUsd !== null && (
  <CostScreen tokens={tokenEstimate} estimatedUsd={costEstimateUsd} />
)}
```

4. Update SummaryCard's `hasApiKey` prop — after key is stored, the "Change key" link should be available. Track this with a simple derived check: the key exists if we've been through key-stored at any point. Use local state in App or simply always show "Change key" when phase is complete (since after Phase 2 onboarding, a key is always stored). For simplicity, pass `hasApiKey={true}` whenever `phase === 'complete'` after the first clustering run. For now, keep `hasApiKey={false}` in the summary card until Plan 02-05 completes — the "Change key" link is a Phase 2 polish detail that becomes relevant in practice after first use.

Destructure `tokenEstimate, costEstimateUsd` from `useAppStore()` in App.
  </action>
  <verify>
    <automated>cd /Users/darrellwhitelaw/Claude/chatgpt-to-claude && npx tsc --noEmit 2>&1 | head -20</automated>
    <manual>Confirm CostScreen.tsx in src/screens/. Confirm useCluster.ts in src/hooks/. Confirm App.tsx has cost-ready routing to CostScreen. Confirm tsc passes.</manual>
  </verify>
  <done>
    `npx tsc --noEmit` passes. CostScreen renders token count and dollar estimate in a single `<p>` with middot separator matching "~2.4M tokens · estimated $1.20" format. High-cost warning callout appears above $3.00. useCluster.fetchCostEstimate handles INVALID_API_KEY: prefix and routes back to ApiKeyScreen. App.tsx has useEffect triggering fetchCostEstimate when phase transitions to key-stored.
  </done>
</task>

<task type="checkpoint:human-verify" gate="blocking">
  <name>Checkpoint: Verify cost estimation and Proceed/Cancel flow</name>
  <action>Verify cost estimation, CostScreen display, and Proceed/Cancel flow work correctly in the running app.</action>
  <what-built>
    Cost estimation end-to-end:
    - Rust estimate_cost command calls /v1/messages/count_tokens with real API key
    - CostScreen shows token count and USD estimate in single line: "~2.4M tokens · estimated $1.20"
    - High-cost warning appears when estimate > $3.00
    - Proceed transitions to clustering phase (ClusteringView placeholder)
    - Cancel returns to summary card
    - Invalid API key detected here: Keychain cleared, user returned to ApiKeyScreen with error
  </what-built>
  <how-to-verify>
    1. Run `npm run dev` (or `pnpm dev`)
    2. Drop the ChatGPT export ZIP → summary card appears
    3. Click Continue → ApiKeyScreen appears (first launch) or skips to counting tokens (key stored)
    4. Enter a VALID Anthropic API key (from console.anthropic.com) → should transition to "Counting tokens..." then show CostScreen with real token count and dollar estimate
    5. Verify the format: "~2.4M tokens · estimated $1.20" (single line with middot separator, actual numbers vary by export size)
    6. If your export is large (> ~7,500 conversations), verify the amber warning callout appears
    7. Click Cancel → should return to summary card
    8. Click Continue again → should skip ApiKeyScreen (key is stored) and go straight to CostScreen
    9. Click Proceed → should show "Clustering conversations..." progress placeholder
    10. Optional: enter an INVALID key and verify ApiKeyScreen shows "Invalid API key — check console.anthropic.com" inline
  </how-to-verify>
  <resume-signal>Type "approved" if cost estimation flow works correctly, or describe any issues</resume-signal>
</task>

</tasks>

<verification>
`cd /Users/darrellwhitelaw/Claude/chatgpt-to-claude/src-tauri && cargo check` — exits 0.
`cd /Users/darrellwhitelaw/Claude/chatgpt-to-claude && npx tsc --noEmit` — exits 0.

estimate_cost registered in lib.rs generate_handler!.
CostScreen shows tokens + USD in single-line middot format.
$3.00 threshold warning present.
</verification>

<success_criteria>
- `cargo check` and `npx tsc --noEmit` both pass
- estimate_cost command reads key from Keychain (not frontend state), calls count_tokens API
- 401 response: Keychain entry deleted, "INVALID_API_KEY:" error returned to frontend
- CostScreen displays "{formatTokens(tokens)} tokens · estimated ${estimatedUsd.toFixed(2)}" in a single `<p>` element
- Warning callout appears at > $3.00 estimate
- Proceed → clustering phase; Cancel → complete phase (summary card)
- useCluster.fetchCostEstimate auto-triggered when phase transitions to key-stored
- Human checkpoint approved
</success_criteria>

<output>
After completion, create `.planning/phases/02-api-key-ai-clustering/02-04-SUMMARY.md`
</output>
